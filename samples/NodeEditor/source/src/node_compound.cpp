/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QMessageBox>
#include "node_compound.h"
#include "node_editorwidget.h"
#include "node_port.h"

namespace Magus
{
    //****************************************************************************/
    QtCompoundNode::QtCompoundNode(QString title, QGraphicsItem* parent) : QtNode(title, parent)
    {
        setData(NODE_KEY_GRAPHIC_ITEM_SUBTYPE, QVariant(NODE_VALUE_SUBTYPE_COMPOUND));
        mAutoSize = false;
    }

    //****************************************************************************/
    QtCompoundNode::~QtCompoundNode(void)
    {
    }

    //****************************************************************************/
    void QtCompoundNode::_prepareDelete(void)
    {
        // First release the nodes
        foreach(QtNode* node, mNodeList)
            removeNode(node);

        mNodeList.clear();
    }

    //****************************************************************************/
    void QtCompoundNode::mouseLeftClickAction2ButtonHandler(QGraphicsSceneMouseEvent* mouseEvent, QGraphicsItem* item)
    {
        _prepareDelete();
        QtNode::mouseLeftClickAction2ButtonHandler(mouseEvent, item);
        mScene->update();
    }

    //****************************************************************************/
    void QtCompoundNode::addNode(QtNode* node)
    {
        if (!node)
            return;

        mNodeList.append(node);
        node->setParentItem(this);

        // Take over the ports of the included nodes
        QVector<QtPort*> ports = node->getPorts();
        node->setVisible(false);
        QtConnection* connection;
        QtPort* createdPort;
        bool isBasePort;
        foreach(QtPort* port, ports)
        {
            connection = port->getConnection();
            isBasePort = port->isBasePort();

            // Add a copy of the port to this compound
            createdPort = createPort(port->getPortId(),
                                        port->getPortName(),
                                        port->getPortType(),
                                        port->getPortColour(),
                                        port->getPortShape(),
                                        port->getAlignment(),
                                        port->getConnectionColour());
            createdPort->setCopyOfPort(port);

            // Rewire the connection
            if (connection)
            {
                createdPort->setConnection(connection, isBasePort);
                connection->setVisible(true);
            }
        }

        // Set connections of this node to front
        foreach(QtPort* portFromCompound, mPortList)
        {
            connection = portFromCompound->getConnection();
            if (connection)
                setZValue(connection->zValue() - 1.0f);
        }

        emit nodeAdded(node);
    }

    //****************************************************************************/
    void QtCompoundNode::removeNode(QtNode* node)
    {
        if (!node)
            return;

        // Remove it from the list
        QVector<QtNode*>::iterator i = mNodeList.begin(); // Use std-style iterator, because of the erase
        QtNode* item;
        while (i != mNodeList.end())
        {
            item = *i;
            if (item == node)
            {
                mNodeList.erase(i);
                break;
            }
        }

        // Set the original parent
        node->_restoreOriginalParentItem();

        // Restore the connections
        QtConnection* connection;
        QtPort* referencePort;
        bool isBasePort;
        foreach(QtPort* port, mPortList)
        {
            // If the reference of the port in the compound is a port in the node, rewire the connection
            referencePort = port->getCopyOfPort();
            isBasePort = port->isBasePort();
            if (node->isPortOfThisNode(referencePort))
            {
                connection = port->getConnection();
                if (referencePort)
                {
                    referencePort->setConnection(connection, isBasePort); // Note, that connection may be 0
                    node->stackBefore(connection);
                    port->setConnection(0, false); // 'Clear' the connection of the compound
                    // TODO: Delete the port of the compound instead
                }
            }
        }

        node->setVisible(true);
        node->update();
        emit nodeRemoved(node);
    }

    //****************************************************************************/
    bool QtCompoundNode::isNodeOfThisCompound (QtNode* node)
    {
        foreach(QtNode* nodeFromList, mNodeList)
        {
            if (node == nodeFromList)
                return true;
        }

        return false;
    }

    //****************************************************************************/
    QVector<QtNode*> QtCompoundNode::getNodes(void)
    {
        return mNodeList;
    }

    //****************************************************************************/
    bool QtCompoundNode::isCompoundNode(QtNode* node)
    {
        if (node->data(NODE_KEY_GRAPHIC_ITEM_SUBTYPE).isValid())
        {
            int subType = node->data(NODE_KEY_GRAPHIC_ITEM_SUBTYPE).toInt();
            return NODE_VALUE_SUBTYPE_COMPOUND == subType;
        }

        return false;
    }

}
