/****************************************************************************
**
** Copyright (C) 2014
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QVBoxLayout>
#include <QMessageBox>
#include <QLabel>
#include <QGraphicsSceneMouseEvent>
#include <QGuiApplication>
#include "node_editorwidget.h"
#include "node_node.h"
#include "node_port.h"
#include "node_connection.h"
#include "node_compound.h"
#include "node_scene.h"

namespace Magus
{
    //****************************************************************************/
    QtNodeEditor::QtNodeEditor(QWidget* parent) : QWidget(parent)
    {
        QVBoxLayout* mainLayout = new QVBoxLayout;
        mView = new QGraphicsView(this);
        mScene = new QtNodeGraphicsScene();
        mScene->installEventFilter(this);
        mView->setScene(mScene);
        mView->setRenderHint(QPainter::Antialiasing, true);
        mView->setInteractive(true);
        mView->setMouseTracking(true);
        mainLayout->addWidget(mView);
        mLastRemovedNode = 0;
        mRubberBand = 0;
        mZoom = 1.0f;
        mFisheyeViewEnabled = false;
        mFisheyeMaxZoom = 1.0f;
        mFisheyeSteps = 5;
        mHeaderTitleIcon = NODE_HEADER_COMPOUND_ICON;
        mAction1Icon = NODE_HEADER_ACTION1_ICON;
        mAction2Icon = NODE_HEADER_ACTION2_ICON;
        mCompoundNodeDropped = 0;
        mRubberbandSelection = false;
        mContextMenuEnabled = true;
        mContextMenu = new QMenu(this);
        mContextMenu->addAction(new QAction(NODE_ACTION_DELETE, this));
        mContextMenu->addAction(new QAction(NODE_ACTION_CENTER, this));
        mZoomSubMenu = mContextMenu->addMenu(NODE_ACTION_ZOOM);
        QAction* action;
        QActionGroup actionGroupZoom(mZoomSubMenu);
        actionGroupZoom.setExclusive(true);
        action = new QAction(NODE_ACTION_ZOOM_10, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_25, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_50, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_75, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_90, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_100, this);
        action->setCheckable(true);
        action->setChecked(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_150, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_200, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_250, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        action = new QAction(NODE_ACTION_ZOOM_300, this);
        action->setCheckable(true);
        actionGroupZoom.addAction(action);
        mZoomSubMenu->addActions(actionGroupZoom.actions());

        mFisheyeViewSubMenu = mContextMenu->addMenu(NODE_ACTION_FISHEY_VIEW);
        QActionGroup actionGroupFisheye(mFisheyeViewSubMenu);
        actionGroupFisheye.setExclusive(true);
        action = new QAction(NODE_ACTION_FISHEYE_DISABLED, this);
        action->setCheckable(true);
        action->setChecked(true);
        actionGroupFisheye.addAction(action);
        action = new QAction(NODE_ACTION_FISHEYE_NORMAL, this);
        action->setCheckable(true);
        actionGroupFisheye.addAction(action);
        action = new QAction(NODE_ACTION_FISHEYE_NORMAL_SUBTLE, this);
        action->setCheckable(true);
        actionGroupFisheye.addAction(action);
        action = new QAction(NODE_ACTION_FISHEYE_LARGE, this);
        action->setCheckable(true);
        actionGroupFisheye.addAction(action);
        action = new QAction(NODE_ACTION_FISHEYE_LARGE_SUBTLE, this);
        action->setCheckable(true);
        actionGroupFisheye.addAction(action);
        mFisheyeViewSubMenu->addActions(actionGroupFisheye.actions());

        mContextMenu->addAction(new QAction(NODE_ACTION_SELECTED_TO_COMPOUND, this));
        mContextMenu->addAction(new QAction(NODE_ACTION_COLLAPSE_ALL, this));
        mContextMenu->addAction(new QAction(NODE_ACTION_EXPAND_ALL, this));
        mContextMenu->addAction(new QAction(NODE_ACTION_EXPAND_COMPOUNDS, this));
        mContextMenu->addAction(new QAction(NODE_ACTION_CENTER, this));

        setMenuZoomEnabled(true);
        setMenuSelectionToCompoundEnabled(true);
        setMenuCollapseExpandEnabled(true);
        setMenuExpandCompoundsEnabled(true);
        setMenuFisheyeViewEnabled(true);
        setContextMenuPolicy(Qt::CustomContextMenu);
        connect(mContextMenu, SIGNAL(triggered(QAction*)), this, SLOT(contextMenuItemSelected(QAction*)));
        setLayout(mainLayout);
    }

    //****************************************************************************/
    QtNodeEditor::~QtNodeEditor(void)
    {
    }

    //****************************************************************************/
    void QtNodeEditor::setContextMenuEnabled(bool enabled)
    {
        mContextMenuEnabled = enabled;
    }

    //****************************************************************************/
    void QtNodeEditor::setCompoundHeaderTitleIcon(const QString& fileNameIcon)
    {
        mHeaderTitleIcon = fileNameIcon;
    }

    //****************************************************************************/
    void QtNodeEditor::setCompoundAction1Icon(const QString& fileNameIcon)
    {
        mAction1Icon = fileNameIcon;
    }

    //****************************************************************************/
    void QtNodeEditor::setCompoundAction2Icon(const QString& fileNameIcon)
    {
        mAction2Icon = fileNameIcon;
    }

    //****************************************************************************/
    bool QtNodeEditor::isContextMenuEnabled(void)
    {
        return mContextMenuEnabled;
    }

    //****************************************************************************/
    void QtNodeEditor::setMenuZoomEnabled(bool enabled)
    {
        mMenuZoomEnabled = enabled;
        QAction* action = getActionFromContextMenu(NODE_ACTION_ZOOM);
        if (action)
            action->setVisible(enabled);
    }

    //****************************************************************************/
    bool QtNodeEditor::isMenuZoomEnabled(void)
    {
        return mMenuZoomEnabled;
    }

    //****************************************************************************/
    void QtNodeEditor::setMenuSelectionToCompoundEnabled(bool enabled)
    {
        mMenuSelectionToCompoundEnabled = enabled;
        QAction* action = getActionFromContextMenu(NODE_ACTION_SELECTED_TO_COMPOUND);
        if (action)
            action->setVisible(enabled);
    }

    //****************************************************************************/
    bool QtNodeEditor::isMenuSelectionToCompoundEnabled(void)
    {
        return mMenuSelectionToCompoundEnabled;
    }

    //****************************************************************************/
    void QtNodeEditor::setMenuCollapseExpandEnabled(bool enabled)
    {
        mMenuCollapseExpandEnabled = enabled;
        QAction* action = getActionFromContextMenu(NODE_ACTION_EXPAND_ALL);
        if (action)
            action->setVisible(enabled);
        action = getActionFromContextMenu(NODE_ACTION_COLLAPSE_ALL);
        if (action)
            action->setVisible(enabled);
    }

    //****************************************************************************/
    bool QtNodeEditor::isMenuCollapseExpandEnabled(void)
    {
        return mMenuCollapseExpandEnabled;
    }

    //****************************************************************************/
    void QtNodeEditor::setMenuExpandCompoundsEnabled(bool enabled)
    {
        mMenuExpandCompoundsEnabled = enabled;
        QAction* action = getActionFromContextMenu(NODE_ACTION_EXPAND_COMPOUNDS);
        if (action)
            action->setVisible(enabled);
    }

    //****************************************************************************/
    bool QtNodeEditor::isMenuExpandCompoundsEnabled(void)
    {
        return mMenuExpandCompoundsEnabled;
    }

    //****************************************************************************/
    void QtNodeEditor::setMenuFisheyeViewEnabled(bool enabled)
    {
        mMenuFisheyeViewEnabled = enabled;
        QAction* action = getActionFromContextMenu(NODE_ACTION_FISHEY_VIEW);
        if (action)
            action->setVisible(enabled);
    }

    //****************************************************************************/
    bool QtNodeEditor::isMenuFisheyeViewEnabled(void)
    {
        return mMenuFisheyeViewEnabled;
    }

    //****************************************************************************/
    void QtNodeEditor::setFisheyeView(bool enabled, qreal maxZoom, unsigned int steps)
    {
        mFisheyeViewEnabled = enabled;
        mFisheyeMaxZoom = maxZoom;
        mFisheyeSteps = steps;
    }

    //****************************************************************************/
    QGraphicsItem* QtNodeEditor::itemAtExceptActiveConnection(const QPointF& pos)
    {
        QList<QGraphicsItem*> items = mScene->items(QRectF(pos - QPointF(1,1), QSize(3,3)));
        bool isActive = isActiveConnection();

        foreach(QGraphicsItem* item, items)
        {
            // If there is an active connection, it is not returned as a selected item
            // Finalized (established) connections are returned
            if (item->isVisible())
            {
                if (isConnection(item))
                {
                    if (!isActive)
                        return item;
                }
                else
                    return item;
            }
        }

        return 0;
    }

    //****************************************************************************/
    QtCompoundNode* QtNodeEditor::nodeOverCompound(QtNode* node)
    {
        if (!node)
            return 0;

        QtCompoundNode* compound;
        QList<QGraphicsItem*> items = mScene->items();
        int subType;
        qreal halfWidth;
        foreach(QGraphicsItem* item, items)
        {
            if (isCompoundNode(item) && item->isVisible())
            {
                compound = static_cast<QtCompoundNode*>(item);
                if (node != compound && !compound->isSelected())
                {
                    halfWidth = 0.5 * compound->getWidth();
                    if (node->scenePos().x() > compound->scenePos().x() - halfWidth &&
                        node->scenePos().x() < compound->scenePos().x() + halfWidth &&
                        node->scenePos().y() > compound->scenePos().y() &&
                        node->scenePos().y() < compound->scenePos().y() + compound->getHeigth())
                    {
                        return compound;
                    }
                }
            }
        }

        return 0;
    }

    //****************************************************************************/
    bool QtNodeEditor::eventFilter(QObject* object, QEvent* event)
    {
        QGraphicsSceneMouseEvent* mouseEvent = (QGraphicsSceneMouseEvent*) event;
        QGraphicsItem* item = 0;
        switch ((int) event->type())
        {
            case QEvent::GraphicsSceneMousePress:
                mouseClickHandler(mouseEvent);
            break;

            case QEvent::GraphicsSceneMouseDoubleClick:
                mouseDoubleClickHandler(mouseEvent);
            break;

            case QEvent::GraphicsSceneMouseMove:
            {
                mouseMoveHandler(mouseEvent);
            }
            break;

            case QEvent::GraphicsSceneMouseRelease:
            {
                mouseReleaseHandler(mouseEvent);
            }
            break;
        }
        return QObject::eventFilter(object, event);
    }

    //****************************************************************************/
    bool QtNodeEditor::mouseClickHandler(QGraphicsSceneMouseEvent* mouseEvent)
    {
        switch ((int) mouseEvent->button())
        {
            case Qt::LeftButton:
            {
                QGraphicsItem* item = itemAtExceptActiveConnection(mouseEvent->scenePos());
                if (!item)
                {
                    // Left-click on the canvas, but no item clicked, so deselect nodes and connections
                    deselectAll();
                    mRubberbandSelection = true;
                    mLastMousePosition.setX(mouseEvent->lastScenePos().x());
                    mLastMousePosition.setY(mouseEvent->lastScenePos().y());
                    return true;
                }
                mRubberbandSelection = false;

                // Delegate to the node; either the node itself is clicked, one of its children or a connection
                QtNode* node;
                int type = 0;
                if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid())
                {
                    type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();
                    if (NODE_VALUE_TYPE_CONNECTION == type)
                    {
                        // ======================= Handle selected connection =======================
                        QtConnection* connection = static_cast<QtConnection*>(item);
                        selectConnection(connection);
                    }
                    else if (NODE_VALUE_TYPE_NODE == type)
                    {
                        // ======================= The node itself is clicked =======================
                        node = static_cast<QtNode*>(item);
                        selectNode(node, mouseEvent);
                    }
                    else if (NODE_VALUE_TYPE_HEADER_ICON == type || NODE_VALUE_TYPE_HEADER_TITLE == type)
                    {
                        // ======================= The header title or header icon is clicked =======================
                        node = static_cast<QtNode*>(item->parentItem());
                        selectNode(node, mouseEvent);
                    }
                    else
                    {
                        // A child item of the node is clicked
                        deselectNodes();
                        deselectConnections();
                        node = static_cast<QtNode*>(item->parentItem());

                        if (NODE_VALUE_TYPE_PORT == type)
                        {
                            // ======================= Port is clicked =======================
                            // Either make a connection to another port, or create a new connection
                            QtNode* baseNode = getNodeWithActiveConnection();
                            if (baseNode == 0)
                            {
                                // There is no active connection, so start one
                                node->mouseLeftClickHandler(mouseEvent, item, NODE_ACTION_BASE);
                                setCursor(Qt::ClosedHandCursor);
                            }
                            else if (baseNode != node)
                            {
                                // There is an active connection and the selected port is not part of the baseNode,
                                // so try to establish a connection with the other node
                                if (node->mouseLeftClickHandler(mouseEvent, item, NODE_ACTION_TARGET, baseNode->mActiveConnection))
                                {
                                    // The connection was established, so the active connection on the basenode can be set to 0
                                    baseNode->mActiveConnection = 0;
                                    setCursor(Qt::ArrowCursor);
                                }
                            }
                        }
                        else
                        {
                            node->mouseLeftClickHandler(mouseEvent, item); // Don't do anything with the node after this; it may be deleted
                        }
                    }
                    return true;
                }
            }
            break;

            case Qt::RightButton:
            {
                if (mContextMenuEnabled)
                {
                    QPoint pos;
                    pos.setX(mouseEvent->lastScreenPos().x());
                    pos.setY(mouseEvent->lastScreenPos().y());
                    showContextMenu(pos);
                }
                else
                    deselectAll();

                return true;
            }
            break;
        }

        //mouseEvent->accept();
        return true;
    }

    //****************************************************************************/
    bool QtNodeEditor::mouseDoubleClickHandler(QGraphicsSceneMouseEvent* mouseEvent)
    {
        // Todo
        return true;
    }

    //****************************************************************************/
    bool QtNodeEditor::mouseMoveHandler(QGraphicsSceneMouseEvent* mouseEvent)
    {
        // If a Fisheye view is enabled, apply it
        if (mFisheyeViewEnabled)
        {
            fisheyeZoom(mouseEvent);
        }

        // If there was a rubberband selection started, update its rectangle
        if(mRubberbandSelection && mouseEvent->buttons() & Qt::LeftButton)
        {
            // Rubberband selection
            rubberbandSelection(mouseEvent);
        }

        QtNode* node;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item) && item->isVisible())
            {
                node = static_cast<QtNode*>(item);
                node->mouseMoveHandler(mouseEvent, item);

                // Only perform drag and drop of a node on a compound when the node is selected
                if (node->isSelected() && mouseEvent->buttons() & Qt::LeftButton)
                {
                    QtCompoundNode* compound = nodeOverCompound(node);
                    if (compound)
                    {
                        //setCursor(Qt::SizeAllCursor); // Indication that the node(s) can be dropped
                        setCursor(Qt::CrossCursor); // Indication that the node(s) can be dropped
                        mCompoundNodeDropped = compound;
                        return true;
                    }
                }
            }
        }
        mCompoundNodeDropped = 0;
        setCursor(Qt::ArrowCursor);
        return true;
    }

    //****************************************************************************/
    bool QtNodeEditor::mouseReleaseHandler(QGraphicsSceneMouseEvent* mouseEvent)
    {
        // Determine whether one or mode nodes are dropped on a compound
        if (mCompoundNodeDropped)
        {
            // Add node(s) to the compound
            foreach(QtNode* node, mCurrentlySelectedNodes)
            {
                mCompoundNodeDropped->addNode(node);
            }

            deselectAll();
            mCompoundNodeDropped = 0;
            return true;
        }

        // Handle the rubberband selection, if applicable
        if (!mRubberbandSelection)
            return false;

        if(mouseEvent->button() & Qt::LeftButton)
        {
            if (mRubberBand)
            {
                qreal minX = qMin(mLastMousePosition.x(), mouseEvent->lastScenePos().x());
                qreal maxX = qMax(mLastMousePosition.x(), mouseEvent->lastScenePos().x());
                qreal minY = qMin(mLastMousePosition.y(), mouseEvent->lastScenePos().y());
                qreal maxY = qMax(mLastMousePosition.y(), mouseEvent->lastScenePos().y());
                qreal itemMinX;
                qreal itemMaxX;
                qreal itemMinY;
                qreal itemMaxY;

                // Select the items
                QList<QGraphicsItem*> items = mScene->items();
                QtNode* node;
                QtConnection* connection;
                foreach(QGraphicsItem* item, items)
                {
                    if (isConnection(item) && item->isVisible())
                    {
                        connection = static_cast<QtConnection*>(item);
                        if (connection->getBasePort() && connection->getTargetPort())
                        {
                            itemMinX = qMin(connection->getBasePort()->scenePos().x(), connection->getTargetPort()->scenePos().x());
                            itemMaxX = qMax(connection->getBasePort()->scenePos().x(), connection->getTargetPort()->scenePos().x());
                            itemMinY = qMin(connection->getBasePort()->scenePos().y(), connection->getTargetPort()->scenePos().y());
                            itemMaxY = qMax(connection->getBasePort()->scenePos().y(), connection->getTargetPort()->scenePos().y());
                            if (itemMinX > minX && itemMaxX < maxX && itemMinY > minY && itemMaxY < maxY)
                            {
                                connection->setSelected(true);
                                if (!isConnectionAlreadySelected(connection))
                                    mCurrentlySelectedConnections.append(connection);
                            }
                        }
                    }
                    else if (isNode(item) && item->isVisible())
                    {
                        node = static_cast<QtNode*>(item);
                        itemMinX = node->scenePos().x() - 0.5 * node->sceneBoundingRect().width() + 10;
                        itemMinY = node->scenePos().y() - 0.5 * node->sceneBoundingRect().height() + 10;
                        itemMaxX = itemMinX + node->sceneBoundingRect().width() + 10;
                        itemMaxY = itemMinY + node->sceneBoundingRect().height()  + 10;
                        if (itemMinX > minX && itemMaxX < maxX && itemMinY > minY && itemMaxY < maxY)
                        {
                            node->setSelected(true);
                            if (!isNodeAlreadySelected(node))
                                mCurrentlySelectedNodes.append(node);

                            emit nodeSelected(node);
                            toFront(node);
                        }
                    }
                }

                mRubberBand->hide();
            }

            mRubberbandSelection = false;
        }

        return true;
    }

    //****************************************************************************/
    void QtNodeEditor::keyPressEvent(QKeyEvent* event)
    {
        if (event->key() == Qt::Key_Delete)
        {
            // Delete all selected connections first
            QtPort* basePort;
            QtNode* baseNode;
            foreach(QtConnection* selectedConnection, mCurrentlySelectedConnections)
            {
                // Delete the connection
                if (selectedConnection)
                {
                    basePort = selectedConnection->getBasePort();
                    if (basePort)
                    {
                        baseNode = static_cast<QtNode*>(basePort->parentItem());
                        if (baseNode)
                            baseNode->_emitConnectionDeleted(basePort);
                    }
                    removeConnection(selectedConnection);
                }
            }
            mCurrentlySelectedConnections.clear();

            // Delete all selected nodes
            foreach(QtNode* selectedNode, mCurrentlySelectedNodes)
            {
                // Delete the node
                removeNode(selectedNode);
                //delete selectedNode;
            }
            mCurrentlySelectedNodes.clear();
        }
    }

    //****************************************************************************/
    void QtNodeEditor::fisheyeZoom(QGraphicsSceneMouseEvent* mouseEvent)
    {
        QPointF a = mView->mapToScene(0, 0);
        QPointF b = mView->mapToScene(mView->viewport()->width(), mView->viewport()->height());
        qreal x0 = a.x();
        qreal y0 = a.y();
        qreal x1 = b.x();
        qreal y1 = b.y();
        qreal width = x1 - x0;
        qreal height = y1 - y0;
        qreal widthPadding;
        qreal heightPadding;
        qreal fraction;
        qreal zoom = mZoom;
        qreal zoomStep = (mFisheyeMaxZoom - mZoom) / mFisheyeSteps;
        QtNode* node;
        QPointF pos = mouseEvent->scenePos();
        QGraphicsItem* item;
        QList<QGraphicsItem*> items;
        for (unsigned int i = 2; i <= mFisheyeSteps; ++i)
        {
            items = mScene->items(QRectF(pos - QPointF(0.5 * width, 0.5 * height), QSize(width, height)));
            foreach(item, items)
            {
                if (isNode(item))
                {
                    node = static_cast<QtNode*>(item);
                    node->setZoom(zoom);
                    widthPadding = 0.5 * node->getWidth();
                    heightPadding = node->getHeigth();
                }
            }
            zoom += zoomStep;
            fraction = 1.0f - (qreal)i / mFisheyeSteps;
            width = fraction * width + widthPadding;
            height = fraction * height + heightPadding;
            items.clear();
        }
        mScene->update();
    }

    //****************************************************************************/
    void QtNodeEditor::rubberbandSelection(QGraphicsSceneMouseEvent* mouseEvent)
    {
        // Mouse is pressed and moves => draw rubberband
        qreal x = mouseEvent->lastScenePos().x();
        qreal y = mouseEvent->lastScenePos().y();
        if (!mRubberBand)
        {
            mRubberBand = new QGraphicsRectItem(mLastMousePosition.x(), mLastMousePosition.y(), 0.0f, 0.0f);
            mRubberBand->setPen(QPen(Qt::darkBlue));
            QColor c(Qt::darkBlue);
            c.setAlpha(64);
            mRubberBand->setBrush(c);
            mScene->addItem(mRubberBand);
        }
        mRubberBand->show();
        qreal minX = qMin((qreal)mLastMousePosition.x(), x);
        qreal maxX = qMax((qreal)mLastMousePosition.x(), x);
        qreal minY = qMin((qreal)mLastMousePosition.y(), y);
        qreal maxY = qMax((qreal)mLastMousePosition.y(), y);
        mRubberBand->setRect(minX, minY, maxX - minX, maxY - minY);
    }

    //****************************************************************************/
    void QtNodeEditor::selectNode(QtNode* node, QGraphicsSceneMouseEvent* mouseEvent)
    {
        node->mouseLeftClickHandler(mouseEvent, node);  // pass the node itself also, because this function is also
                                                        // used for other purposes than selecting the node itself
        if (!ctrlPressed())
        {
            deselectAll();
            mCurrentlySelectedNodes.append(node);
        }
        else if (!isNodeAlreadySelected(node))
        {
            mCurrentlySelectedNodes.append(node);
            // Do not call setSelection on the node; the node is selectable, while the connection isn't
        }

        emit nodeSelected(node);
        node->_emitNodeSelected(); // Causes a signal to emit
        toFront(node);
    }

    //****************************************************************************/
    void QtNodeEditor::selectConnection(QtConnection* connection)
    {
        if (!ctrlPressed())
        {
            deselectAll();
            mCurrentlySelectedConnections.append(connection);
            connection->setSelected(true);
        }
        else if (!isConnectionAlreadySelected(connection))
        {
            mCurrentlySelectedConnections.append(connection);
            connection->setSelected(true);
        }
    }

    //****************************************************************************/
    void QtNodeEditor::deselectAll(void)
    {
        setCursor(Qt::ArrowCursor);
        deleteAllActiveConnections();
        deselectConnections();
        deselectNodes();
    }

    //****************************************************************************/
    void QtNodeEditor::deleteAllActiveConnections(void)
    {
        QtNode* node;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item) && item->isVisible())
            {
                node = static_cast<QtNode*>(item);
                node->deleteActiveConnection();
            }
        }
    }

    //****************************************************************************/
    bool QtNodeEditor::isActiveConnection(void)
    {
        QtNode* node;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item) && item->isVisible())
            {
                node = static_cast<QtNode*>(item);
                if (node->mActiveConnection)
                    return true;
            }
        }
        return false;
    }

    //****************************************************************************/
    void QtNodeEditor::deselectConnections(void)
    {
        QtConnection* connection;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isConnection(item) && item->isVisible())
            {
                connection = static_cast<QtConnection*>(item);
                connection->setSelected(false);
            }
        }
        mCurrentlySelectedConnections.clear();
    }

    //****************************************************************************/
    void QtNodeEditor::deselectNodes(void)
    {
        QtNode* node;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item) && item->isVisible())
            {
                node = static_cast<QtNode*>(item);
                node->setSelected(false);
            }
        }
        mCurrentlySelectedNodes.clear();
    }

    //****************************************************************************/
    QtNode* QtNodeEditor::getNodeWithActiveConnection(void)
    {
        QtNode* node;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item) && item->isVisible())
            {
                node = static_cast<QtNode*>(item);
                if (node->mActiveConnection)
                    return node;
            }
        }
        return 0;
    }

    //****************************************************************************/
    void QtNodeEditor::addNode(QtNode* node)
    {
        node->_setEditor(this);
        node->_setScene(mScene);
        mScene->addItem(node);
        node->setZoom(mZoom);
        emit nodeAdded(node);
    }

    //****************************************************************************/
    QVector<QtNode*> QtNodeEditor::getNodes(void)
    {
        QVector<QtNode*> nodeList;
        QtNode* node;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item) && item->isVisible())
            {
                node = static_cast<QtNode*>(item);
                nodeList.append(node);
            }
        }

        return nodeList;
    }

    //****************************************************************************/
    void QtNodeEditor::removeNode(QtNode* node, bool cascade)
    {
        if (!node)
            return;

        QtCompoundNode* compound;
        QVector<QtNode*> nodes;
        mLastRemovedNode = node;
        if (cascade && isCompoundNode(node))
        {
            compound = static_cast<QtCompoundNode*>(node);
            nodes = getNodes();
        }
        node->_prepareDelete();
        emit nodeToBeRemoved(node);
        mScene->removeItem(node);

        // Check the released nodes (if needed)
        if (!nodes.isEmpty())
            foreach(QtNode* releaseNode, nodes)
                if (isCompoundNode(releaseNode))
                    removeNode(releaseNode, cascade);
    }

    //****************************************************************************/
    void QtNodeEditor::removeConnection(QtConnection* connection)
    {
        if (!connection)
            return;

        QtPort* basePort = connection->getBasePort();
        QtPort* targetPort = connection->getTargetPort();
        if (basePort)
        {
            // Connections of a compound node may not be removed
            // A compound node is the only one that has connections were base- and targetports
            // belong to the same parent item.
            if (basePort->parentItem() == targetPort->parentItem())
                return;

            mScene->removeItem(connection);
            basePort->deleteConnection();
        }
    }

    //****************************************************************************/
    void QtNodeEditor::removeAllSelelected(void)
    {
        foreach(QtConnection* selectedConnection, mCurrentlySelectedConnections)
            removeConnection(selectedConnection);

        foreach(QtNode* selectedNode, mCurrentlySelectedNodes)
            removeNode(selectedNode);
    }

    //****************************************************************************/
    void QtNodeEditor::center(void)
    {
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
            if (isNode(item))
                item->setPos(0, 0);
    }

    //****************************************************************************/
    void QtNodeEditor::clear(void)
    {
        mScene->clear(); // removes + deletes all items in the scene
    }

    //****************************************************************************/
    QtNode* QtNodeEditor::getLastSelectedNode(void)
    {
        if (mCurrentlySelectedNodes.empty())
            return 0;

        return mCurrentlySelectedNodes.at(mCurrentlySelectedNodes.count() - 1);
    }

    //****************************************************************************/
    QVector<QtNode*> QtNodeEditor::getSelectedNodes (void)
    {
        return mCurrentlySelectedNodes;
    }

    //****************************************************************************/
    QVector<QtConnection*> QtNodeEditor::getSelectedConnections (void)
    {
        return mCurrentlySelectedConnections;
    }

    //****************************************************************************/
    QtNode* QtNodeEditor::getRemovedNode(void)
    {
        return mLastRemovedNode;
    }

    //****************************************************************************/
    void QtNodeEditor::toFront(QtNode* node)
    {
        if (!node)
            return;

        QList<QGraphicsItem*> items = mScene->items();

        // First set the node in front of all other nodes
        foreach(QGraphicsItem* item, items)
        {
            if (node != item && isNode(item) && item->isVisible())
                item->stackBefore(node);
        }

        // Put the connections of the node in front of the node and the other connections behind the node
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item))
            {
                QtConnection* connection = static_cast<QtConnection*>(item);
                if (node->isConnectionConnectedToThisNode(connection))
                    node->stackBefore(item);
                else
                    item->stackBefore(node);
            }
        }
    }

    //****************************************************************************/
    void QtNodeEditor::toBack(QtNode* node)
    {
        if (!node)
            return;

        QList<QGraphicsItem*> items = mScene->items();

        // Set all other nodes in front of this node
        foreach(QGraphicsItem* item, items)
        {
            if (node != item && isNode(item) && item->isVisible())
                node->stackBefore(item);
        }
    }

    //****************************************************************************/
    void QtNodeEditor::setZoom(qreal zoom)
    {
        mZoom = zoom;
        QtNode* node;
        QList<QGraphicsItem*> items = mScene->items();
        foreach(QGraphicsItem* item, items)
        {
            if (isNode(item) && item->isVisible())
            {
                node = static_cast<QtNode*>(item);
                node->setZoom(zoom);
            }
        }
    }

    //****************************************************************************/
    bool QtNodeEditor::ctrlPressed(void)
    {
        Qt::KeyboardModifiers modifiers = QGuiApplication::keyboardModifiers();
        bool val = false;
        val = modifiers & Qt::ControlModifier;
        return val;
    }

    //****************************************************************************/
    bool QtNodeEditor::isNodeAlreadySelected(QtNode* node)
    {
        foreach(QtNode* selectedNode, mCurrentlySelectedNodes)
            if (node == selectedNode)
                return true;

        return false;
    }

    //****************************************************************************/
    bool QtNodeEditor::isConnectionAlreadySelected(QtConnection* connection)
    {
        foreach(QtConnection* selectedConnection, mCurrentlySelectedConnections)
            if (connection == selectedConnection)
                return true;

        return false;
    }

    //****************************************************************************/
    void QtNodeEditor::showContextMenu(const QPoint& pos)
    {
        if (!mContextMenu)
            return;

        QList<QAction*> actions = mContextMenu->actions();
        QList<QAction*>::iterator i;
        QAction* action;
        bool itemsSelected = !mCurrentlySelectedNodes.isEmpty() || !mCurrentlySelectedConnections.isEmpty();
        bool nodesSelected = !mCurrentlySelectedNodes.isEmpty();
        QFont font;
        font.setItalic(!itemsSelected); // Italic when no selected items available
        for (i = actions.begin(); i != actions.end(); ++i)
        {
            action = *i;
            if (action->text() == NODE_ACTION_DELETE)
            {
                action->setFont(font);
                action->setEnabled(itemsSelected);
            }
            if (action->text() == NODE_ACTION_SELECTED_TO_COMPOUND)
            {
                action->setFont(font);
                action->setEnabled(nodesSelected);
            }
        }
        mContextMenu->popup(pos);
    }

    //****************************************************************************/
    QAction* QtNodeEditor::getActionFromContextMenu(const QString& actionText)
    {
        if (!mContextMenu)
            return 0;

        QList<QAction*> actions = mContextMenu->actions();
        foreach(QAction* action, actions)
            if (action->text() == actionText)
                return action;

        return 0;
    }

    //****************************************************************************/
    void QtNodeEditor::setZoomForAction(qreal zoom, QAction* action)
    {
        setZoom(zoom);
        resetZoomSubmenu();
        action->setChecked(true);
    }

    //****************************************************************************/
    void QtNodeEditor::resetZoomSubmenu(void)
    {
        QList<QAction*> actions = mZoomSubMenu->actions();
        foreach(QAction* action, actions)
            action->setChecked(false);
    }

    //****************************************************************************/
    void QtNodeEditor::setFisheyeForAction(QAction* action, bool enabled, qreal maxZoom, unsigned int steps)
    {
        setFisheyeView(enabled, maxZoom, steps);
        resetFisheySubmenu();
        action->setChecked(true);
    }

    //****************************************************************************/
    void QtNodeEditor::resetFisheySubmenu(void)
    {
        QList<QAction*> actions = mFisheyeViewSubMenu->actions();
        foreach(QAction* action, actions)
            action->setChecked(false);
    }

    //****************************************************************************/
    void QtNodeEditor::contextMenuItemSelected(QAction* action)
    {
        // ---------------- Delete action ----------------
        if (action->text() == NODE_ACTION_DELETE)
        {
            // Delete the selected nodes and connections from the scene
            removeAllSelelected();
            return;
        }

        // ---------------- Center action ----------------
        if (action->text() == NODE_ACTION_CENTER)
        {
            // Center all nodes
            center();
            return;
        }

        // ---------------- Zoom action ----------------
        if (action->text() == NODE_ACTION_ZOOM_10)
        {
            setZoomForAction(0.1f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_25)
        {
            setZoomForAction(0.25f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_50)
        {
            setZoomForAction(0.5f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_75)
        {
            setZoomForAction(0.75f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_90)
        {
            setZoomForAction(0.9f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_100)
        {
            setZoomForAction(1.0f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_150)
        {
            setZoomForAction(1.5f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_200)
        {
            setZoomForAction(2.0f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_250)
        {
            setZoomForAction(2.5f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_300)
        {
            setZoomForAction(3.0f, action);
            return;
        }

        if (action->text() == NODE_ACTION_ZOOM_10)
        {
            setZoomForAction(0.1f, action);
            return;
        }

        // ---------------- Fisheye action ----------------
        if (action->text() == NODE_ACTION_FISHEYE_DISABLED)
        {
            setFisheyeForAction(action, false);
            return;
        }
        if (action->text() == NODE_ACTION_FISHEYE_NORMAL)
        {
            setFisheyeForAction(action, true, 1.4f);
            return;
        }
        if (action->text() == NODE_ACTION_FISHEYE_NORMAL_SUBTLE)
        {
            setFisheyeForAction(action, true, 1.1f, 10);
            return;
        }
        if (action->text() == NODE_ACTION_FISHEYE_LARGE)
        {
            setFisheyeForAction(action, true, 1.7f);
            return;
        }
        if (action->text() == NODE_ACTION_FISHEYE_LARGE_SUBTLE)
        {
            setFisheyeForAction(action, true, 1.5f, 10);
            return;
        }

        // ---------------- To compound action ----------------
        if (action->text() == NODE_ACTION_SELECTED_TO_COMPOUND)
        {
            // Add the selected nodes to a compound
            QtCompoundNode* compound = new QtCompoundNode(QString("Compound"));
            compound->setTitleColor(Qt::white);
            compound->setHeaderTitleIcon(mHeaderTitleIcon);
            compound->setAction1Icon(mAction1Icon);
            compound->setAction2Icon(mAction2Icon);
            compound->alignTitle(Magus::ALIGNED_LEFT);
            compound->setHeaderColor(QColor("#888888"));
            compound->setAutoSize(true);
            emit selectedNodesToBeAddedToCompound(); // First emit the signal before the nodes are added to the compound
            foreach(QtNode* node, mCurrentlySelectedNodes)
            {
                compound->addNode(node);
                compound->setPos(node->pos());
            }
            addNode(compound);
            mCurrentlySelectedNodes.clear();
            return;
        }

        // ---------------- Collapse action ----------------
        if (action->text() == NODE_ACTION_COLLAPSE_ALL)
        {
            QtNode* node;
            QList<QGraphicsItem*> items = mScene->items();
            foreach(QGraphicsItem* item, items)
            {
                if (isNode(item) && item->isVisible())
                {
                    node = static_cast<QtNode*>(item);
                    node->collapse();
                }
            }
            return;
        }

        // ---------------- Expand action ----------------
        if (action->text() == NODE_ACTION_EXPAND_ALL)
        {
            QtNode* node;
            QList<QGraphicsItem*> items = mScene->items();
            foreach(QGraphicsItem* item, items)
            {
                if (isNode(item) && item->isVisible())
                {
                    node = static_cast<QtNode*>(item);
                    node->expand();
                }
            }
            return;
        }

        // ---------------- Expand compounds action ----------------
        if (action->text() == NODE_ACTION_EXPAND_COMPOUNDS)
        {
            QtCompoundNode* compound;
            QList<QGraphicsItem*> items = mScene->items();
            foreach(QGraphicsItem* item, items)
            {
                if (isCompoundNode(item) && item->isVisible())
                {
                    compound = static_cast<QtCompoundNode*>(item);
                    removeNode(compound, true);
                }
            }
            return;
        }
    }

    //****************************************************************************/
    bool QtNodeEditor::isNode(QGraphicsItem* item)
    {
        if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid())
        {
            int type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();
            return NODE_VALUE_TYPE_NODE == type;
        }

        return false;
    }

    //****************************************************************************/
    bool QtNodeEditor::isCompoundNode(QGraphicsItem* item)
    {
        if (item->data(NODE_KEY_GRAPHIC_ITEM_SUBTYPE).isValid())
        {
            int subType = item->data(NODE_KEY_GRAPHIC_ITEM_SUBTYPE).toInt();
            return NODE_VALUE_SUBTYPE_COMPOUND == subType;
        }

        return false;
    }

    //****************************************************************************/
    bool QtNodeEditor::isConnection(QGraphicsItem* item)
    {
        if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid())
        {
            int type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();
            return NODE_VALUE_TYPE_CONNECTION == type;
        }

        return false;
    }

    //****************************************************************************/
    void QtNodeEditor::wheelEvent (QWheelEvent* event)
    {
        if ((event->delta() > 0 && mZoom < 3.0f) ||
            (event->delta() < 0 && mZoom > 0.25f))
                setZoom(mZoom + 0.001 * event->delta());

        mScene->update();
    }
}
