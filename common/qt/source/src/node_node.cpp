/****************************************************************************
**
** Copyright (C) 2016
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

// Include
#include <QMessageBox>
#include <QStyleOptionGraphicsItem>
#include <QLinearGradient>
#include <QPen>
#include <QBrush>
#include <QColor>
#include <QPainter>
#include <QPixmap>
#include "node_constants.h"
#include "node_node.h"
#include "node_port.h"
#include "node_editorwidget.h"

namespace Magus
{
    //****************************************************************************/
    QtNode::QtNode(QString title, QGraphicsItem* parent) : QGraphicsPathItem(parent)
    {
        // Header
        mZoom = 1.0f;
        mActiveConnection = 0;
        mUserData = 0;
        mPixmapItem = new QGraphicsPixmapItem(this);
        mImageSet = false;
        mAutoSize = true;
        mIconSize = mZoom * NODE_HEADER_ICON_SIZE;
        mNormalizedWidth = NODE_WIDTH;
        mNormalizedBodyHeight = NODE_BODY_HEIGHT;
        mWidth = mZoom * mNormalizedWidth;
        mHeaderHeight = mZoom * NODE_HEADER_HEIGHT;
        mBodyHeight = mZoom * mNormalizedBodyHeight;
        mPortNameColor = Qt::white;

        QLinearGradient linearGrad(0, 0, 300, NODE_HEADER_HEIGHT);
        linearGrad.setColorAt(0, QColor("#945555"));
        linearGrad.setColorAt(0.2, QColor("#3e3e3e"));
        mHeaderBrush = QBrush(linearGrad);
        setFlag(QGraphicsItem::ItemIsMovable);
        setFlag(QGraphicsItem::ItemIsSelectable);

        // Add icons to the header
        mHeaderTitleIcon = new QGraphicsPixmapItem(this); // MUST be a child of QtNode
        mAction1Icon = new QGraphicsPixmapItem(this); // MUST be a child of QtNode
        mAction2Icon = new QGraphicsPixmapItem(this); // MUST be a child of QtNode
        mHeaderTitleIcon->setScale(0.0f);
        mAction1Icon->setScale(0.0f);
        mAction2Icon->setScale(0.0f);
        mHeaderTitleIcon->setVisible(false);
        mAction1Icon->setVisible(false);
        mAction2Icon->setVisible(false);

        // Body
        mBody = new QGraphicsPathItem(this); // MUST be a child of QtNode
        QPainterPath bodyPath;
        mBody->setBrush(QColor("#3e3e3e"));
        mBody->setFlag(QGraphicsItem::ItemStacksBehindParent);

        // Generic
        setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_NODE));
        mHeaderTitleIcon->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_HEADER_ICON));
        mAction1Icon->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_ACTION_1_ICON));
        mAction2Icon->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_ACTION_2_ICON));
        mBody->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_NODE_BODY));

        // Set title
        mTitle = title;
        mTitleLabel = new QGraphicsTextItem(this);
        mTitleLabel->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_HEADER_TITLE));
        mTitleLabel->setPlainText(mTitle);
        mFontHeader.setPointSize(mZoom * NODE_HEADER_TITLE_FONT_SIZE);
        mTitleLabel->setFont(mFontHeader);
        mTitleAlignment = ALIGNED_CENTER;
        adjustWidthForTitle();
    }

    //****************************************************************************/
    QtNode::~QtNode(void)
    {
    }

    //****************************************************************************/
    void QtNode::setAutoSize (bool autoSize)
    {
        mAutoSize = autoSize;
    }

    //****************************************************************************/
    bool QtNode::isAutoSize (void) const
    {
        return mAutoSize;
    }

    //****************************************************************************/
    void QtNode::setWidth(qreal width)
    {
        mWidth = width;
        redraw();
    }

    //****************************************************************************/
    void QtNode::setHeaderHeight(qreal headerHeight)
    {
        mHeaderHeight = headerHeight;
        redraw();
    }

    //****************************************************************************/
    void QtNode::setBodyHeight(qreal bodyHeight)
    {
        mBodyHeight = bodyHeight;
        redraw();
    }

    //****************************************************************************/
    qreal QtNode::getWidth(void) const
    {
        return mWidth;
    }

    //****************************************************************************/
    qreal QtNode::getHeigth(void) const
    {
        if (mBody->isVisible())
            return mBodyHeight;
        else
            return mHeaderHeight;
    }

    //****************************************************************************/
    void QtNode::adjustWidthForTitle(void)
    {
        // Adjust the width of the node, depending on total width of the title and the icons
        // Calculate using zoom factor 1.0
        qreal offset = 0.5f * (NODE_HEADER_HEIGHT - NODE_HEADER_ICON_SIZE);
        mFontHeader.setPointSize(NODE_HEADER_TITLE_FONT_SIZE);
        mTitleLabel->setFont(mFontHeader);
        //qreal unzoomedTitleWidth = mTitleLabel->boundingRect().width();
        qreal spaceLeft = mNormalizedWidth;
        if (mHeaderTitleIcon->isVisible())
        {
            spaceLeft -= NODE_HEADER_ICON_SIZE;
            spaceLeft -= offset;
        }
        if (mAction1Icon->isVisible())
        {
            spaceLeft -= NODE_HEADER_ICON_SIZE;
            spaceLeft -= offset;
        }
        if (mAction2Icon->isVisible())
        {
            spaceLeft -= NODE_HEADER_ICON_SIZE;
            spaceLeft -= offset;
        }
        if (mTitleLabel->boundingRect().width() > spaceLeft)
        {
            mNormalizedWidth += mTitleLabel->boundingRect().width() - spaceLeft;
        }

        // Set values to original zoom factor
        mFontHeader.setPointSize(mZoom * NODE_HEADER_TITLE_FONT_SIZE);
        mTitleLabel->setFont(mFontHeader);
        mWidth = mZoom * mNormalizedWidth;
        redraw();
    }


    //****************************************************************************/
    void QtNode::redraw(void)
    {
        // Redraw the node
        qreal halfWidth = 0.5f * mWidth;
        qreal offset = 0.5f * (mHeaderHeight - mIconSize);

        QPainterPath p;
        p.addRoundedRect(-halfWidth, 0, mWidth, mHeaderHeight, mZoom * 4, mZoom * 5);
        setPath(p);

        QPainterPath bodyPath;
        bodyPath.addRoundedRect(-halfWidth, 0, mWidth, mBodyHeight, mZoom * 4, mZoom * 5);
        mBody->setPath(bodyPath);

        mFontHeader.setPointSize(mZoom * NODE_HEADER_TITLE_FONT_SIZE);
        mTitleLabel->setFont(mFontHeader);
        if (mHeaderTitleIcon->isVisible())
            mHeaderTitleIcon->setScale(mIconSize/mHeaderTitleIcon->pixmap().width()); // Scale may only be set if visible
        if (mAction1Icon->isVisible())
            mAction1Icon->setScale(mIconSize/mAction1Icon->pixmap().width()); // Scale may only be set if visible
        if (mAction2Icon->isVisible())
            mAction2Icon->setScale(mIconSize/mAction2Icon->pixmap().width()); // Scale may only be set if visible
        mHeaderTitleIcon->setPos(-halfWidth + offset, offset);
        mAction1Icon->setPos(halfWidth - 2 * (mIconSize + offset), offset);
        mAction2Icon->setPos(halfWidth - (mIconSize + offset), offset);
        setTitlePosition();

        // Redraw image
        qreal height = NODE_BODY_HEIGHT;
        if (mImageSet)
        {
            qreal scale = NODE_IMAGE_FRACTION * (mWidth / mImage.width());
            if (mPixmapItem->isVisible())
                mPixmapItem->setScale(scale); // Scale may only be set if visible
            mPixmapItem->setPos(-0.5 * NODE_IMAGE_FRACTION * mWidth, mZoom * height);
            height = height + NODE_IMAGE_FRACTION * mNormalizedWidth;
        }

        // Redraw ports
        foreach(QtPort* port, mPortList)
        {
            port->redraw();
            if (port->isVisible())
            {
                // This is in case the node is not collapsed
                height += NODE_PORT_HEIGHT_MARGIN_FACTOR * port->getNormalizedHeight();
                setPortAlignedPos(port, mZoom * height);
            }
            else
            {
                // This is in case the node (and its ports) is collapsed; the port's height must be on
                // the correct y-position (on the header), so the connections also remain on that position.
                height = NODE_PORT_HEIGHT_MARGIN_FACTOR * port->getNormalizedHeight();
                setPortAlignedPos(port, mZoom * height);
            }
        }
    }

    //****************************************************************************/
    void QtNode::setZoom(qreal zoom)
    {
        mZoom = zoom;
        mIconSize = mZoom * NODE_HEADER_ICON_SIZE;
        mWidth = mZoom * mNormalizedWidth;
        mHeaderHeight = mZoom * NODE_HEADER_HEIGHT;
        mBodyHeight = mZoom * mNormalizedBodyHeight;

        // Set zoom for all ports
        foreach(QtPort* port, mPortList)
            port->setZoom(mZoom);

        redraw();
    }

    //****************************************************************************/
    void QtNode::setHeaderColor(const QColor& color)
    {
        QLinearGradient linearGrad(0, 0, 300, NODE_HEADER_HEIGHT);
        linearGrad.setColorAt(0, color);
        linearGrad.setColorAt(0.2, QColor("#3e3e3e"));
        mHeaderBrush = QBrush(linearGrad);
    }

    //****************************************************************************/
    void QtNode::setTitleColor(const QColor& color)
    {
        mTitleLabel->setDefaultTextColor(color);
    }

    //****************************************************************************/
    void QtNode::setPortNameColor(const QColor& color)
    {
        mPortNameColor = color;
        foreach(QtPort* port, mPortList)
            port->setNameColor(color);
    }

    //****************************************************************************/
    void QtNode::alignTitle(Alignment alignment)
    {
        mTitleAlignment = alignment;
        setTitlePosition();
    }

    //****************************************************************************/
    void QtNode::setTitlePosition(void)
    {
        qreal halfWidth = 0.5f * mWidth;
        qreal offset = 0.5f * (mHeaderHeight - mIconSize);
        switch (mTitleAlignment)
        {
            case ALIGNED_LEFT:
            {
                if (mHeaderTitleIcon->isVisible())
                {
                    // Position it right to the icon
                    mTitleLabel->setPos(-halfWidth + mIconSize + offset,
                                        0.5 * (mHeaderHeight - mTitleLabel->boundingRect().height()));
                }
                else
                {
                    // Position it where the icon should be
                    mTitleLabel->setPos(-halfWidth + offset,
                                        0.5 * (mHeaderHeight - mTitleLabel->boundingRect().height()));
                }
            }
            break;

            case ALIGNED_RIGHT:
            {
                if (mAction1Icon->isVisible())
                {
                    // Position it left from action1 icon
                    mTitleLabel->setPos(halfWidth - 2 * (offset + mIconSize) - mTitleLabel->boundingRect().width(),
                                        0.5 * (mHeaderHeight - mTitleLabel->boundingRect().height()));                }
                else
                {
                    if (mAction2Icon->isVisible())
                    {
                        // Position it left from action2 icon
                        mTitleLabel->setPos(halfWidth - offset - mIconSize - mTitleLabel->boundingRect().width(),
                                            0.5 * (mHeaderHeight - mTitleLabel->boundingRect().height()));
                    }
                    else
                    {
                        // Position it right
                        mTitleLabel->setPos(halfWidth - offset - mTitleLabel->boundingRect().width(),
                                            0.5 * (mHeaderHeight - mTitleLabel->boundingRect().height()));
                    }
                }
            }
            break;

            case ALIGNED_CENTER:
            {
                mTitleLabel->setPos(-0.5 * mTitleLabel->boundingRect().width(),
                                    0.5 * (mHeaderHeight - mTitleLabel->boundingRect().height()));
            }
            break;
        }
    }

    //****************************************************************************/
    void QtNode::_setEditor(QtNodeEditor* editor)
    {
        mEditor = editor;
    }

    //****************************************************************************/
    void QtNode::_setScene(QGraphicsScene* scene)
    {
        mScene = scene;
    }

    //****************************************************************************/
    void QtNode::setHeaderTitleIcon(const QString& fileNameIcon)
    {
        QPixmap pixmap (fileNameIcon);
        mHeaderTitleIcon->setPixmap(pixmap);
        if (pixmap.width() != 0)
        {
            mHeaderTitleIcon->setScale(mIconSize/pixmap.width());
            mHeaderTitleIcon->setVisible(true);
        }
        adjustWidthForTitle();
    }

    //****************************************************************************/
    void QtNode::setAction1Icon(const QString& fileNameIcon)
    {
        QPixmap pixmap (fileNameIcon);
        mAction1Icon->setPixmap(pixmap);
        if (pixmap.width() != 0)
        {
            mAction1Icon->setScale(mIconSize/pixmap.width());
            mAction1Icon->setVisible(true);
        }
        adjustWidthForTitle();
    }

    //****************************************************************************/
    void QtNode::setAction2Icon(const QString& fileNameIcon)
    {
        QPixmap pixmap (fileNameIcon);
        mAction2Icon->setPixmap(pixmap);
        if (pixmap.width() != 0)
        {
            mAction2Icon->setScale(mIconSize/pixmap.width());
            mAction2Icon->setVisible(true);
        }
        adjustWidthForTitle();
    }

    //****************************************************************************/
    void QtNode::setIconSize(qreal size)
    {
        mIconSize = size;
    }

    //****************************************************************************/
    bool QtNode::mouseLeftClickHandler(QGraphicsSceneMouseEvent* mouseEvent,
                                       QGraphicsItem* item,
                                       unsigned int action,
                                       QtConnection* activeConnection)
    {
        int type = 0;
        if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid())
            type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();

        switch (type)
        {
            case NODE_VALUE_TYPE_PORT:
            {
                QtPort* port = static_cast<QtPort*>(item);

                // Check wether the port is available; if not, return false
                if (!port->isPortOpen())
                    return false;

                if (action == NODE_ACTION_BASE)
                {
                    // Create a new connection; this node is the baseNode (with the base port)
                    createActiveConnection(port, mouseEvent->scenePos());
                }
                else if (action == NODE_ACTION_TARGET && activeConnection)
                {
                    // Check wether the connection is allowed; if not, return false
                    // This node is the target node (with the target port)
                    QtPort* basePort = activeConnection->getBasePort();
                    if (!port->isConnectionAllowed(basePort))
                        return false;

                    // Finalize the connection; this node is the targetNode
                    if (activeConnection)
                    {
                        port->createConnection(activeConnection);
                        emit connectionEstablished(this, port, activeConnection);
                    }
                }
            }
            break;

            case NODE_VALUE_TYPE_ACTION_1_ICON:
            {
                emit action1Clicked(this);
                mouseLeftClickAction1ButtonHandler(mouseEvent, item);
            }
            break;

            case NODE_VALUE_TYPE_ACTION_2_ICON:
            {
                emit action2Clicked(this);
                mouseLeftClickAction2ButtonHandler(mouseEvent, item);
            }
            break;
        }

        return true;
    }

    //****************************************************************************/
    void QtNode::mouseLeftClickAction1ButtonHandler(QGraphicsSceneMouseEvent* mouseEvent, QGraphicsItem* item)
    {
        if (mBody->isVisible())
            collapse();
        else
            expand();

        /*
        // Toggle visibility of the body
        mBody->setVisible(!mBody->isVisible());

        // Toggle visibility of the ports
        bool isPortVisible;
        foreach(QtPort* port, mPortList)
        {
            //port->setVisible(!port->isVisible());
            isPortVisible = port->isVisible();
            if (isPortVisible)
                port->collapse();
            else
                port->expand();
        }
        */
    }

    //****************************************************************************/
    void QtNode::mouseLeftClickAction2ButtonHandler(QGraphicsSceneMouseEvent* mouseEvent, QGraphicsItem* item)
    {
        // Delegate to the editor
        mEditor->removeNode(this);
    }

    //****************************************************************************/
    bool QtNode::mouseRightClickHandler(QGraphicsSceneMouseEvent* mouseEvent,
                                        QGraphicsItem* item,
                                        unsigned int action,
                                        QtConnection* activeConnection)
    {
        // TODO
        return true;
    }

    //****************************************************************************/
    bool QtNode::mouseDoubleClickHandler(QGraphicsSceneMouseEvent* mouseEvent, QGraphicsItem* item)
    {
        // TODO
        return true;
    }

    //****************************************************************************/
    bool QtNode::mouseMoveHandler(QGraphicsSceneMouseEvent* mouseEvent, QGraphicsItem* item)
    {
        if (mActiveConnection)
        {
            // There is an active connection, so the connection is dragged with the mouse cursor
            mActiveConnection->updatePath(mouseEvent->scenePos());
        }

        return true;
    }

    //****************************************************************************/
    void QtNode::collapse(void)
    {
        // Set visibility of the image
        mPixmapItem->setVisible(false);

        // Set visibility of the body
        mBody->setVisible(false);

        // Set visibility of the ports
        foreach(QtPort* port, mPortList)
            if (port->isVisible())
                port->collapse();
    }

    //****************************************************************************/
    void QtNode::expand(void)
    {
        // Set visibility of the image
        mPixmapItem->setVisible(true);

        // Set visibility of the body
        mBody->setVisible(true);

        // Set visibility of the ports
        foreach(QtPort* port, mPortList)
            if (!port->isVisible())
                port->expand();

        if (mImageSet)
            redraw(); // Needed to scale the image (image does not scale if not visible)
    }

    //****************************************************************************/
    void QtNode::createActiveConnection(QtPort* port, QPointF pos)
    {
        mActiveConnection = port->createConnection();
        mScene->addItem(mActiveConnection);
        mActiveConnection->updatePath(pos);
        emit connectionStarted(this, port, mActiveConnection);
    }

    //****************************************************************************/
    void QtNode::deleteActiveConnection(void)
    {
        if (mActiveConnection)
        {
            QtPort* port = mActiveConnection->getBasePort();
            mScene->removeItem(mActiveConnection);
            port->deleteConnection();
            mActiveConnection = 0;
        }
    }

    //****************************************************************************/
    void QtNode::deleteAllConnections(void)
    {
        foreach(QtPort* port, mPortList)
        {
            QtConnection* connection = port->getConnection();
            mScene->removeItem(connection);
            port->deleteConnection();
        }
    }

    //****************************************************************************/
    void QtNode::selectConnections(bool selected)
    {
        foreach(QtPort* port, mPortList)
        {
            QtConnection* connection = port->getConnection();
            if (connection && (connection != mActiveConnection))
                connection->setSelected(selected);
        }
    }

    //****************************************************************************/
    void QtNode::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget)
    {
        Q_UNUSED(option)
        Q_UNUSED(widget)

        // Paint header
        painter->setBackgroundMode(Qt::OpaqueMode);
        painter->setBrush(mHeaderBrush);

        if (isSelected())
        {
            mPen.setColor("#cc7800");
            mPen.setWidth(mZoom * NODE_PEN_WIDTH_SELECTED);
        }
        else
        {
            mPen.setColor(Qt::black);
            mPen.setWidth(mZoom * NODE_PEN_WIDTH_UNSELECTED);
        }

        painter->setPen(mPen);
        mBody->setPen(mPen);
        painter->drawPath(path());

        // Only update the connection if it not the active one
        foreach(QtPort* port, mPortList)
        {
            if (port->getConnection() != mActiveConnection)
                port->updateConnection();
        }
    }

    //****************************************************************************/
    QtPort* QtNode::createPort(unsigned int portId,
                               const QString& portName,
                               QtPortType portType,
                               QColor portColour,
                               QtPortShape portShape,
                               Alignment alignement,
                               QColor connectionColor)
    {
        QtPort* port = new QtPort(portId, portName, portType, portColour, connectionColor, portShape, alignement, mZoom, this);
        port->setNameColor(mPortNameColor);
        port->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_PORT));
        mPortList.append(port);

        if (mAutoSize)
        {
            mNormalizedBodyHeight += NODE_PORT_HEIGHT_MARGIN_FACTOR * port->getNormalizedHeight();
            mBodyHeight = mZoom * mNormalizedBodyHeight;

            // Adjust width of the node (if needed) to fit the port
            qreal normalized = port->getNormalizedWidth() + 2.5f * NODE_PORT_OFFSET;
            if (normalized > mNormalizedWidth)
                mNormalizedWidth = normalized;
            mWidth = mZoom * mNormalizedWidth;
        }

        setPortAlignedPos(port, mBodyHeight);
        redraw();

        return port;
    }

    //****************************************************************************/
    void QtNode::setImage(const QString& fileNameImage)
    {
        mImage = QPixmap(fileNameImage);
        setImage(mImage);
    }

    //****************************************************************************/
    void QtNode::setImage(const QPixmap& pixMap)
    {
        mImage = pixMap;
        mPixmapItem->setPixmap(mImage);

        if (mAutoSize)
        {
            if (!mImageSet)
            {
                mNormalizedBodyHeight += NODE_IMAGE_FRACTION * mNormalizedWidth;
                mBodyHeight = mZoom * mNormalizedBodyHeight;
            }
        }

        mImageSet = true;
        redraw();
    }

    //****************************************************************************/
    void QtNode::setPortAlignedPos(QtPort* port, qreal height)
    {
        // Position
        qreal halfWidth = 0.5f * mWidth;
        qreal offset = mZoom * NODE_PORT_OFFSET;
        qreal portWidth = mZoom * port->getNormalizedWidth();
        switch (port->getAlignment())
        {
            case ALIGNED_LEFT:
            {
                port->setAlignedPos(-halfWidth + offset, height - offset);
            }
            break;

            case ALIGNED_RIGHT:
            {
                port->setAlignedPos(halfWidth - offset, height - offset);
            }
            break;

            case ALIGNED_CENTER:
            {
                port->setAlignedPos(-0.5 * portWidth, height - offset);
            }
            break;
        }
    }

    //****************************************************************************/
    void QtNode::_emitNodeSelected(void)
    {
        emit nodeSelected(this);
    }

    //****************************************************************************/
    void QtNode::_emitConnectionDeleted(QtPort* port)
    {
        emit connectionDeleted(this, port);
    }

    //****************************************************************************/
    void QtNode::setParentItem(QGraphicsItem* parent)
    {
        mOriginalParent = parentItem();
        QGraphicsPathItem::setParentItem(parent);
    }

    //****************************************************************************/
    void QtNode::_restoreOriginalParentItem(void)
    {
        setParentItem(mOriginalParent);
    }

    //****************************************************************************/
    void QtNode::_prepareDelete(void)
    {
        deleteAllConnections();
    }

    //****************************************************************************/
    QtPort* QtNode::getPort (const QString& portName)
    {
        // 1. Run through all of the ports in this node
        // 2. Return the first occurence of port with the same name
        foreach(QtPort* port, mPortList)
        {
            if (port->getPortName() == portName)
                return port;
        }

        return 0;
    }

    //****************************************************************************/
    QtPort* QtNode::getPort (unsigned int portId)
    {
        // 1. Run through all of the ports in this node
        // 2. Return the port with the same portId
        foreach(QtPort* port, mPortList)
        {
            if (port->getPortId() == portId)
                return port;
        }

        return 0;
    }

    //****************************************************************************/
    QtPort* QtNode::getPort (const QString& portName, unsigned int occurence)
    {
        // 1. Run through all of the ports in this node
        // 2. Return the n-th occurence of the port with the same name
        unsigned int count = 1;
        foreach(QtPort* port, mPortList)
        {
            if (port->getPortName() == portName)
            {
                if (count == occurence)
                    return port;

                ++count;
            }
        }

        return 0;
    }


    //****************************************************************************/
    QVector<QtPort*> QtNode::getPorts (void)
    {
        QVector<QtPort*> ports;
        foreach(QtPort* port, mPortList)
            ports.append(port);

        return ports;
    }

    //****************************************************************************/
    QVector<QtPort*> QtNode::getPorts (const QString& portName)
    {
        // 1. Run through all of the ports in this node
        // 2. Append all the ports with the same name to a vector
        // 3. Return the vector
        QVector<QtPort*> ports;
        foreach(QtPort* port, mPortList)
        {
            if (port->getPortName() == portName)
            {
                ports.append(port);
            }
        }

        return ports;
    }

    //****************************************************************************/
    bool QtNode::isPortOfThisNode(QtPort* port)
    {
        // 1. Run through all of the ports in this node
        // 2. Return true if a port in this list is the same as the port passed as an argument
        foreach(QtPort* portFromList, mPortList)
        {
            if (port == portFromList)
                return true;
        }

        return false;
    }

    //****************************************************************************/
    bool QtNode::isPortOfThisNode(unsigned int portId)
    {
        // 1. Run through all of the ports in this node
        // 2. Return true if there is a port in this list with the same portId
        foreach(QtPort* port, mPortList)
        {
            if (port->getPortId() == portId)
                return true;
        }

        return false;
    }

    //****************************************************************************/
    bool QtNode::isPortOfThisNode(const QString& portName)
    {
        return getPort(portName);
    }

    //****************************************************************************/
    bool QtNode::isConnectionConnectedToThisNode(QtConnection* connection)
    {
        foreach(QtPort* port, mPortList)
        {
            if (connection == port->getConnection())
                return true;
        }
        return false;
    }

    //****************************************************************************/
    QtNode* QtNode::getNodeConnectedToPort (QtPort* port)
    {
        // 1. Get the port that is connected to the given port (of this node)
        // 2. If there is a connected port, return its parent node
        QtNode* node = 0;
        QtPort* connectedPort = getPortConnectedToPort (port);
        if (connectedPort)
            node = static_cast<QtNode*>(connectedPort->parentItem());

        return node;
    }

    //****************************************************************************/
    QtNode* QtNode::getNodeConnectedToPort (unsigned int portId)
    {
        // 1. Get the port that is connected to the given port (of this node)
        // 2. If there is a connected port, return its parent node
        QtNode* node = 0;
        QtPort* connectedPort = getPortConnectedToPort (portId);
        if (connectedPort)
            node = static_cast<QtNode*>(connectedPort->parentItem());

        return node;
    }

    //****************************************************************************/
    QtNode* QtNode::getNodeConnectedToPort (const QString& portName)
    {
        // 1. Get the port that is connected to the given port (of this node)
        // 2. If there is a connected port, return its parent node
        QtNode* node = 0;
        QtPort* connectedPort = getPortConnectedToPort (portName);
        if (connectedPort)
            node = static_cast<QtNode*>(connectedPort->parentItem());

        return node;
    }

    //****************************************************************************/
    QtNode* QtNode::getNodeConnectedToPort (const QString& portName, unsigned int occurence)
    {
        // 1. Get the n-th occurence of the port that is connected with the port of this node
        // 2. Return its parent node
        QtNode* node = 0;
        QtPort* connectedPort = getPortConnectedToPort (portName, occurence);
        if (connectedPort)
            node = static_cast<QtNode*>(connectedPort->parentItem());

        return node;
    }

    //****************************************************************************/
    QVector<QtNode*> QtNode::getNodesConnectedToPorts (const QString& portName)
    {
        // 1. Get all ports that are connected to the ports (with the same name) of this node
        // 2. Append their parent nodes to the vector
        QVector<QtNode*> connectedNodes;
        QVector<QtPort*> connectedPorts = getPortsConnectedToPorts (portName);
        foreach(QtPort* connectPort, connectedPorts)
            connectedNodes.append(static_cast<QtNode*>(connectPort->parentItem()));

        return connectedNodes;
    }

    //****************************************************************************/
    QtPort* QtNode::getCheckedPortConnectedToPort (QtPort* port)
    {
        // Assume that the port is part of 'this' node
        QtConnection* connection = port->getConnection();
        if (!connection)
            return 0;

        // There is a connection; determine whether it is a finalished (established) connection
        // Both ports must exist
        QtPort* basePort = connection->getBasePort();
        if (!basePort)
            return 0;

        QtPort* targetPort = connection->getTargetPort();
        if (!targetPort)
            return 0;

        if (port == basePort)
        {
            // The port of 'this' node is the base port; use the target port
            return targetPort;
        }
        else if (port == targetPort)
        {
            // The port of 'this' node is the target port; use the base port
            return basePort;
        }

        return 0;
    }

    //****************************************************************************/
    QtPort* QtNode::getPortConnectedToPort (QtPort* port)
    {
        // First check whether the port is part of this node
        if (!isPortOfThisNode(port))
            return 0;

        return getCheckedPortConnectedToPort(port);
    }

    //****************************************************************************/
    QtPort* QtNode::getPortConnectedToPort (unsigned int portId)
    {
        // First get the port
        QtPort* port = getPort(portId);
        if (!port)
            return 0;

        return getCheckedPortConnectedToPort(port);
    }

    //****************************************************************************/
    QtPort* QtNode::getPortConnectedToPort (const QString& portName)
    {
        // First get the port
        QtPort* port = getPort(portName);
        if (!port)
            return 0;

        return getCheckedPortConnectedToPort(port);
    }

    //****************************************************************************/
    QtPort* QtNode::getPortConnectedToPort (const QString& portName, unsigned int occurence)
    {
        QtPort* port = getPort(portName, occurence);
        if (!port)
            return 0;

        return getCheckedPortConnectedToPort(port);
    }

    //****************************************************************************/
    QVector<QtPort*> QtNode::getPortsConnectedToPorts (const QString& portName)
    {
        // 1. Get the ports of this node with the same name
        // 2. Get for each port the connected port
        QVector<QtPort*> ports = getPorts(portName);
        QVector<QtPort*> connectedPorts;
        foreach(QtPort* port, ports)
            connectedPorts.append(getCheckedPortConnectedToPort(port));

        return connectedPorts;
    }

    //****************************************************************************/
    void QtNode::setVisible(bool visible)
    {
        // Also make the connected nodes visible/invisible
        foreach(QtPort* port, mPortList)
            if (port->getConnection())
                port->getConnection()->setVisible(visible);

        QGraphicsPathItem::setVisible(visible);
    }

}
